# chamar a fun√ß√£o para escolher o diretorio
diretorio = escolher_diretorio()
if diretorio:
    print(f"‚úÖ Diret√≥rio selecionado: {diretorio}")
else:
    print("‚ö†Ô∏è Nenhum diret√≥rio foi selecionado")

# chamar a fun√ß√£o para escolher os arquivos csv
arquivos = escolher_arquivos()

# verificar se os arquivos foram escolhidos
if arquivos is None or len(arquivos) == 0:
    print("‚ùå Nenhum arquivo foi selecionado.")
    print("üí° Dica: Execute a c√©lula novamente e selecione exatamente 2 arquivos CSV")
elif len(arquivos) != 2:
    print(f"‚ö†Ô∏è Foram selecionados {len(arquivos)} arquivos. Por favor, selecione exatamente 2 arquivos CSV.")
    print("üí° Execute a c√©lula novamente e selecione apenas 2 arquivos")
else:
    print(f"‚úÖ Exatos 2 arquivos selecionados!")
    
    # mostrar os arquivos selecionados
    arquivo1 = arquivos[0]
    arquivo2 = arquivos[1]
    print(f"1. {arquivo1.split('\\')[-1]}")
    print(f"2. {arquivo2.split('\\')[-1]}")
    
    print("\nüìÇ Carregando os arquivos...")
    
    def carregar_arquivo_robusto(caminho_arquivo):
        """
        Tenta carregar o arquivo com diferentes encodings
        """
        encodings = ['utf-8', 'latin-1', 'iso-8859-1', 'cp1252', 'utf-16']
        
        for encoding in encodings:
            try:
                df = pd.read_csv(caminho_arquivo, sep=',', encoding=encoding)
                print(f"‚úÖ Arquivo carregado com encoding: {encoding}")
                return df
            except UnicodeDecodeError:
                continue
            except Exception as e:
                print(f"‚ö†Ô∏è Erro com encoding {encoding}: {e}")
                continue
        
        # Se todos os encodings falharam, tentar com engine='python'
        try:
            df = pd.read_csv(caminho_arquivo, sep=',', encoding='utf-8', engine='python')
            print("‚úÖ Arquivo carregado com engine='python'")
            return df
        except Exception as e:
            print(f"‚ùå Falha ao carregar arquivo: {e}")
            return None
    
    try:
        # carregar o primeiro arquivo
        print("üîÑ Carregando arquivo 1...")
        df1 = carregar_arquivo_robusto(arquivo1)
        nome_arquivo1 = arquivo1.split('\\')[-1]
        
        if df1 is not None:
            print(f"‚úÖ Arquivo 1 carregado: {nome_arquivo1} - Shape: {df1.shape}")
        else:
            print(f"‚ùå Falha ao carregar arquivo 1: {nome_arquivo1}")
            df1 = None
        
        # carregar o segundo arquivo
        print("üîÑ Carregando arquivo 2...")
        df2 = carregar_arquivo_robusto(arquivo2)
        nome_arquivo2 = arquivo2.split('\\')[-1]
        
        if df2 is not None:
            print(f"‚úÖ Arquivo 2 carregado: {nome_arquivo2} - Shape: {df2.shape}")
        else:
            print(f"‚ùå Falha ao carregar arquivo 2: {nome_arquivo2}")
            df2 = None
        
        # Exibir informa√ß√µes apenas se ambos os arquivos foram carregados
        if df1 is not None and df2 is not None:
            print("\n" + "="*60)
            print(f"üìä DISPLAY DO PRIMEIRO ARQUIVO: {nome_arquivo1}")
            print("="*60)
            print(f"üîπ Colunas ({len(df1.columns)}): {list(df1.columns)}")
            print(f"üîπ Primeiras 5 linhas:")
            try:
                display(df1.head())
            except:
                print(df1.head())
            
            print("\n" + "="*60)
            print(f"üìä DISPLAY DO SEGUNDO ARQUIVO: {nome_arquivo2}")
            print("="*60)
            print(f"üîπ Colunas ({len(df2.columns)}): {list(df2.columns)}")
            print(f"üîπ Primeiras 5 linhas:")
            try:
                display(df2.head())
            except:
                print(df2.head())
            
            # informa√ß√µes detalhadas usando info()
            print("\nüìä INFORMA√á√ïES DETALHADAS DO ARQUIVO 1:")
            print(f"üîπ {nome_arquivo1}")
            try:
                df1.info(verbose=True)
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao exibir info do arquivo 1: {e}")
                print(f"üìä Resumo b√°sico: {df1.shape[0]} linhas, {df1.shape[1]} colunas")
            
            print("\nüìä INFORMA√á√ïES DETALHADAS DO ARQUIVO 2:")
            print(f"üîπ {nome_arquivo2}")
            try:
                df2.info(verbose=True)
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao exibir info do arquivo 2: {e}")
                print(f"üìä Resumo b√°sico: {df2.shape[0]} linhas, {df2.shape[1]} colunas")
            
            # resumo r√°pido da compara√ß√£o
            print(f"\nüîÑ RESUMO COMPARATIVO:")
            print(f"üìã Arquivo 1: {df1.shape[0]:,} linhas x {df1.shape[1]} colunas")
            print(f"üìã Arquivo 2: {df2.shape[0]:,} linhas x {df2.shape[1]} colunas")
            print(f"üìä Diferen√ßa: {abs(df1.shape[0] - df2.shape[0]):,} linhas, {abs(df1.shape[1] - df2.shape[1])} colunas")
            
            # Verificar se as colunas s√£o iguais
            colunas_iguais = list(df1.columns) == list(df2.columns)
            print(f"üîó Colunas id√™nticas: {'‚úÖ Sim' if colunas_iguais else '‚ùå N√£o'}")
            
            if not colunas_iguais:
                print("üîç Diferen√ßas nas colunas:")
                colunas_df1 = set(df1.columns)
                colunas_df2 = set(df2.columns)
                
                apenas_df1 = colunas_df1 - colunas_df2
                apenas_df2 = colunas_df2 - colunas_df1
                
                if apenas_df1:
                    print(f"   üìã Apenas no arquivo 1: {list(apenas_df1)}")
                if apenas_df2:
                    print(f"   üìã Apenas no arquivo 2: {list(apenas_df2)}")
            
            print("\n‚úÖ PROCESSAMENTO CONCLU√çDO!")
            
        else:
            print("‚ùå N√£o foi poss√≠vel carregar um ou ambos os arquivos.")
            
    except Exception as e:
        print(f"‚ùå Erro geral no processamento: {e}")
        import traceback
        traceback.print_exc()

# üìÅ ORGANIZA√á√ÉO DOS ARQUIVOS GERADOS
print("üìÅ ORGANIZA√á√ÉO DOS ARQUIVOS GERADOS")
print("="*60)

import os
import shutil
from datetime import datetime

# Verificar se a estrutura de pastas existe
base_dir = "g:/PROJETOS PYTHON/aeronautas_azul"
estrutura_pastas = {
    "logs": os.path.join(base_dir, "RESULTADOS", "logs"),
    "relatorios": os.path.join(base_dir, "RESULTADOS", "relatorios"),
    "arquivos_padronizados": os.path.join(base_dir, "RESULTADOS", "arquivos_padronizados"),
    "codigos": os.path.join(base_dir, "CODIGOS GERADOS", "analises")
}

# Criar pastas se n√£o existirem
print("üèóÔ∏è Verificando estrutura de pastas...")
for nome, caminho in estrutura_pastas.items():
    if not os.path.exists(caminho):
        try:
            os.makedirs(caminho, exist_ok=True)
            print(f"‚úÖ Criada: {nome} -> {caminho}")
        except Exception as e:
            print(f"‚ùå Erro ao criar {nome}: {e}")
    else:
        print(f"‚úÖ Existe: {nome} -> {caminho}")

print("\nüìã MAPEAMENTO DOS ARQUIVOS PARA ORGANIZAR:")

# Definir mapeamento dos arquivos
arquivos_mover = {
    # Arquivos de log -> pasta logs
    "logs": [
        "log.csv",
        "log_jornadas.csv", 
        "log_repouso.csv",
        "log_repousoextra.csv"
    ],
    
    # Relat√≥rios de compara√ß√£o -> pasta relatorios
    "relatorios": [
        "relatorio_comparacao_colunas_*.csv",
        "relatorio_comparacao_colunas_*.xlsx",
        "relatorio_comparacao_colunas_*.json",
        "relatorio_comparacao_colunas_*_resumo.txt"
    ],
    
    # Arquivos padronizados -> pasta arquivos_padronizados
    "arquivos_padronizados": [
        "arquivo1_padronizado.csv",
        "arquivo2_padronizado.csv",
        "*_CALCULOS_EM_TIMEDELTA.csv",
        "*_padronizado.csv"
    ]
}

# Fun√ß√£o para encontrar arquivos com padr√£o
def encontrar_arquivos_padrao(padrao):
    """Encontra arquivos que correspondem ao padr√£o"""
    import glob
    return glob.glob(padrao)

# Fun√ß√£o para mover arquivo com timestamp
def mover_arquivo_com_backup(origem, destino_pasta, nome_arquivo):
    """Move arquivo para pasta de destino, criando backup se j√° existir"""
    destino_completo = os.path.join(destino_pasta, nome_arquivo)
    
    try:
        # Se arquivo j√° existe no destino, criar backup
        if os.path.exists(destino_completo):
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            nome_base, extensao = os.path.splitext(nome_arquivo)
            backup_nome = f"{nome_base}_backup_{timestamp}{extensao}"
            backup_caminho = os.path.join(destino_pasta, backup_nome)
            shutil.move(destino_completo, backup_caminho)
            print(f"   üì¶ Backup criado: {backup_nome}")
        
        # Mover arquivo
        shutil.move(origem, destino_completo)
        return True, destino_completo
        
    except Exception as e:
        return False, str(e)

# Processar cada categoria de arquivos
print("\nüîÑ MOVENDO ARQUIVOS...")

arquivos_movidos = []
arquivos_nao_encontrados = []
erros_movimento = []

for categoria, lista_arquivos in arquivos_mover.items():
    pasta_destino = estrutura_pastas[categoria]
    
    print(f"\nüìÇ Categoria: {categoria.upper()}")
    print(f"   Destino: {pasta_destino}")
    
    for padrao_arquivo in lista_arquivos:
        if '*' in padrao_arquivo:
            # Arquivo com padr√£o
            arquivos_encontrados = encontrar_arquivos_padrao(padrao_arquivo)
            
            if arquivos_encontrados:
                print(f"   üîç Padr√£o '{padrao_arquivo}': {len(arquivos_encontrados)} arquivo(s)")
                
                for arquivo_completo in arquivos_encontrados:
                    nome_arquivo = os.path.basename(arquivo_completo)
                    
                    if os.path.exists(arquivo_completo):
                        sucesso, resultado = mover_arquivo_com_backup(arquivo_completo, pasta_destino, nome_arquivo)
                        
                        if sucesso:
                            print(f"      ‚úÖ {nome_arquivo} -> movido")
                            arquivos_movidos.append({
                                'arquivo': nome_arquivo,
                                'categoria': categoria,
                                'destino': resultado
                            })
                        else:
                            print(f"      ‚ùå {nome_arquivo} -> erro: {resultado}")
                            erros_movimento.append({
                                'arquivo': nome_arquivo,
                                'erro': resultado
                            })
            else:
                print(f"   ‚ö†Ô∏è Padr√£o '{padrao_arquivo}': nenhum arquivo encontrado")
                arquivos_nao_encontrados.append(padrao_arquivo)
        
        else:
            # Arquivo espec√≠fico
            if os.path.exists(padrao_arquivo):
                sucesso, resultado = mover_arquivo_com_backup(padrao_arquivo, pasta_destino, padrao_arquivo)
                
                if sucesso:
                    print(f"   ‚úÖ {padrao_arquivo} -> movido")
                    arquivos_movidos.append({
                        'arquivo': padrao_arquivo,
                        'categoria': categoria,
                        'destino': resultado
                    })
                else:
                    print(f"   ‚ùå {padrao_arquivo} -> erro: {resultado}")
                    erros_movimento.append({
                        'arquivo': padrao_arquivo,
                        'erro': resultado
                    })
            else:
                print(f"   ‚ö†Ô∏è {padrao_arquivo} -> n√£o encontrado")
                arquivos_nao_encontrados.append(padrao_arquivo)

# Relat√≥rio final
print("\n" + "="*60)
print("üìä RELAT√ìRIO FINAL DA ORGANIZA√á√ÉO")
print("="*60)

print(f"\n‚úÖ ARQUIVOS MOVIDOS COM SUCESSO: {len(arquivos_movidos)}")
if arquivos_movidos:
    for item in arquivos_movidos:
        print(f"   üìÑ {item['arquivo']} -> {item['categoria']}")
        print(f"      üìÇ {item['destino']}")

print(f"\n‚ö†Ô∏è ARQUIVOS N√ÉO ENCONTRADOS: {len(arquivos_nao_encontrados)}")
if arquivos_nao_encontrados:
    for arquivo in arquivos_nao_encontrados:
        print(f"   üìÑ {arquivo}")

print(f"\n‚ùå ERROS NO MOVIMENTO: {len(erros_movimento)}")
if erros_movimento:
    for item in erros_movimento:
        print(f"   üìÑ {item['arquivo']}: {item['erro']}")

# Verificar arquivos restantes no diret√≥rio atual
print(f"\nüìÇ ARQUIVOS RESTANTES NO DIRET√ìRIO ATUAL:")
arquivos_atuais = [f for f in os.listdir('.') if os.path.isfile(f) and f.endswith(('.csv', '.xlsx', '.json', '.txt'))]

if arquivos_atuais:
    print("   Arquivos que podem precisar de organiza√ß√£o manual:")
    for arquivo in arquivos_atuais:
        tamanho = os.path.getsize(arquivo)
        print(f"   üìÑ {arquivo} ({tamanho} bytes)")
else:
    print("   üéâ Nenhum arquivo de trabalho restante!")

# Criar √≠ndice dos arquivos organizados
print(f"\nüìã CRIANDO √çNDICE DOS ARQUIVOS ORGANIZADOS...")

indice_organizacao = {
    'data_organizacao': datetime.now().isoformat(),
    'total_movidos': len(arquivos_movidos),
    'total_erros': len(erros_movimento),
    'total_nao_encontrados': len(arquivos_nao_encontrados),
    'estrutura_pastas': estrutura_pastas,
    'arquivos_movidos': arquivos_movidos,
    'erros': erros_movimento,
    'nao_encontrados': arquivos_nao_encontrados
}

# Salvar √≠ndice
import json
indice_path = os.path.join(estrutura_pastas['relatorios'], 'indice_organizacao.json')
try:
    with open(indice_path, 'w', encoding='utf-8') as f:
        json.dump(indice_organizacao, f, indent=2, ensure_ascii=False)
    print(f"‚úÖ √çndice salvo: {indice_path}")
except Exception as e:
    print(f"‚ùå Erro ao salvar √≠ndice: {e}")

print(f"\nüéØ ORGANIZA√á√ÉO CONCLU√çDA!")
print(f"   üìä Total de arquivos organizados: {len(arquivos_movidos)}")
print(f"   üìÇ Estrutura de pastas: {len(estrutura_pastas)} categorias")
print(f"   üìã √çndice completo salvo para refer√™ncia")

# Mostrar estrutura final
print(f"\nüìÅ ESTRUTURA FINAL ORGANIZADA:")
for categoria, caminho in estrutura_pastas.items():
    if os.path.exists(caminho):
        arquivos_na_pasta = [f for f in os.listdir(caminho) if os.path.isfile(os.path.join(caminho, f))]
        print(f"   üìÇ {categoria}: {len(arquivos_na_pasta)} arquivo(s)")
        for arquivo in arquivos_na_pasta[:5]:  # Mostrar apenas os primeiros 5
            print(f"      üìÑ {arquivo}")
        if len(arquivos_na_pasta) > 5:
            print(f"      ... e mais {len(arquivos_na_pasta) - 5} arquivo(s)")

print(f"\n‚úÖ TODOS OS ARQUIVOS EST√ÉO ORGANIZADOS!")